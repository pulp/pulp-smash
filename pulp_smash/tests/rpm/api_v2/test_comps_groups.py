# coding=utf-8
"""Test groups in comps.xml generated by yum distributor."""
from __future__ import unicode_literals

from pulp_smash import utils, api, selectors
from pulp_smash.compat import urljoin
from pulp_smash.constants import CONTENT_UPLOAD_PATH, REPOSITORY_PATH
from pulp_smash.tests.rpm.api_v2.utils import (
    gen_distributor,
    gen_repo,
    get_repomd_xml
)


def _upload_import_group(server_config, repo, group):
    """Import a single package_group unit to a repo.

    Returns the call report created as a result of the import.
    """
    client = api.Client(server_config, api.json_handler)
    malloc = client.post(CONTENT_UPLOAD_PATH)
    call_report = client.post(
        urljoin(repo['_href'], 'actions/import_upload/'),
        {
            'unit_key': {'id': group['id'], 'repo_id': repo['id']},
            'unit_metadata': group,
            'unit_type_id': 'package_group',
            'upload_id': malloc['upload_id'],
        }
    )
    client.delete(malloc['_href'])
    return call_report


def _get_groups_by_id(comps_tree):
    """Return each "group" element in ``comps_tree``, keyed by ID.

    :param comps_tree: An ``Element``.
    :returns: A dict in the form ``{id, group_element}``.
    """
    return {
        group.find('id').text: group
        for group in comps_tree.findall('group')
    }


def _xml_text_for_boolean(value):
    """Given a boolean ``value``, return expected corresponding XML text.

    :returns: 'true' or 'false'
    :raises: ``ValueError`` if ``value`` is not ``True`` or ``False``
    """
    if value is True:
        return 'true'
    if value is False:
        return 'false'
    raise ValueError(
        'Provided with a value {} (of type {}), but a boolean was expected'
        .format(value, type(value))
    )


def _additional_devel_group():
    """Return a realistic, typical group unit.

    Most supported fields are filled in on this unit and there are a few
    translated strings.
    """
    return {
        'id': 'additional-devel',
        'name': 'Additional Development',
        'translated_name': {
            'es': 'Desarrollo adicional',
            'zh_CN': u'附加开发',
        },
        'description': ('Additional development headers and libraries for '
                        'building open-source applications'),
        'translated_description': {
            'es': (u'Encabezados adicionales y bibliotecas para compilar '
                   u'aplicaciones de código abierto.'),
            'zh_CN': u'用于构建开源应用程序的附加开发标头及程序可。',
        },
        'default': True,
        'user_visible': True,
        'display_order': 55,
        'mandatory_package_names': [
            'PyQt4-devel',
            'SDL-devel'
        ],
        'default_package_names': [
            'perl-devel',
            'polkit-devel'
        ],
        'optional_package_names': [
            'binutils-devel',
            'python-devel'
        ],
        'conditional_package_names': [
            ('perl-Test-Pod', 'perl-devel'),
            ('python-setuptools', 'python-devel')
        ]
    }


def _empty_group():
    """Return a group unit which is as empty as possible.

    This unit omits every non-mandatory field (which, in practice, means that
    it includes only an 'id').
    """
    return {
        'id': 'empty',
    }


class CompsGroupsTestCase(utils.BaseAPITestCase):
    """Tests to ensure ``comps.xml`` can be created and groups are valid."""

    @classmethod
    def setUpClass(cls):
        """Create an RPM repository, upload comps metadata, and publish.

        More specifically:

        1. Create a repository.
        2. Add yum distributor to it.
        3. Import fixture group units.
        4. Publish repository.
        5. Fetch and parse generated ``comps.xml``.
        """
        super(CompsGroupsTestCase, cls).setUpClass()

        client = api.Client(cls.cfg, api.json_handler)

        # Create a repository for use by the test.
        repo = client.post(REPOSITORY_PATH, gen_repo())
        cls.resources.add(repo['_href'])

        # Add yum distributor to the repo
        distribute = client.post(
            urljoin(repo['_href'], 'distributors/'),
            gen_distributor())

        # Import our test groups
        cls.groups = {
            group['id']: group
            for group in [_additional_devel_group(), _empty_group()]
        }

        cls.tasks = {}
        for (group_id, group) in cls.groups.items():
            key = 'import_%s' % group_id
            report = _upload_import_group(cls.cfg, repo, group)
            cls.tasks[key] = tuple(api.poll_spawned_tasks(cls.cfg, report))

        # Publish the repository
        client.post(
            urljoin(repo['_href'], 'actions/publish/'),
            {'id': distribute['id']})

        # Fetch the generated repodata of type 'group' (a.k.a. 'comps')
        repo_url = urljoin(
            '/pulp/repos/',
            distribute['config']['relative_url']
        )
        cls.root_element = get_repomd_xml(client, repo_url, 'group')

    def test_root(self):
        """Assert the root element of the tree has a tag of "comps"."""
        self.assertEqual(self.root_element.tag, 'comps')

    def test_count(self):
        """Assert there is one "group" element per imported group unit."""
        elements = self.root_element.findall('group')
        self.assertEqual(len(elements), len(self.groups))

    def test_ids_alone(self):
        """Assert each "group" element has one "id" child element."""
        for element in self.root_element.findall('group'):
            with self.subTest(element=element):
                self.assertEqual(len(element.findall('id')), 1)

    def test_ids_unique(self):
        """Assert each group ID is unique."""
        ids = set()
        for element in self.root_element.findall('group'):
            for id_element in element.findall('id'):
                id_text = id_element.text
                with self.subTest(id_text=id_text):
                    self.assertNotIn(id_text, ids)
                    ids.add(id_text)

    def test_one_task_per_import(self):
        """Assert only one task is spawned per package group upload."""
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                self.assertEqual(len(tasks), 1)

    def test_tasks_state(self):
        """Assert each task's state is "finished".

        This test assumes :meth:`test_one_task_per_import` passes.
        """
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                self.assertEqual(tasks[0]['state'], 'finished')

    def test_tasks_result(self):
        """Assert each task's result success flag (if present) is true.

        This test assumes :meth:`test_one_task_per_import` passes.
        """
        for key, tasks in self.tasks.items():
            with self.subTest(key=key):
                if 'result' not in tasks[0]:
                    continue
                result = tasks[0]['result']
                self.assertTrue(result['success_flag'], result)

    def test_has_groups(self):
        """Assert that each imported group unit appears in the XML."""
        group_elements = _get_groups_by_id(self.root_element)
        for unit in self.groups.values():
            unit_id = unit['id']
            with self.subTest(unit_id=unit_id):
                self.assertIn(unit_id, group_elements)

    def test_verbatim_string_fields(self):
        """Assert string fields on a unit appear unmodified in generated XML.

        This test covers fields from a group unit which are expected to be
        serialized as-is into top-level tags under a ``<group>``. For example,
        this test asserts that the 'name' attribute on a group unit will appear
        in the generated XML as:

        ::

            <group>
                <name>some-value</name>
                ...
            </group>
        """
        (group_unit, group_element) = self.group_unit_and_element(
            'additional-devel'
        )

        fields = ['id', 'name', 'description', 'display_order']

        for field in fields:
            with self.subTest(field=field):
                unit_text = str(group_unit[field])
                xml_text = group_element.find(field).text
                self.assertEqual(unit_text, xml_text)

    def test_verbatim_boolean_fields(self):
        """Assert boolean fields on a unit appear correctly in generated XML.

        This test is similar to :meth:`test_verbatim_string_fields`,
        but additionally verifies that boolean values are serialized as
        expected in the XML (i.e. as text 'true' or 'false').
        """
        (group_unit, group_element) = self.group_unit_and_element(
            'additional-devel'
        )

        unit_to_xml_fields = {
            # This field is named differently in unit vs XML unfortunately :(
            'user_visible': 'uservisible',
            'default': 'default',
        }

        for (unit_field, xml_field) in unit_to_xml_fields.items():
            with self.subTest(unit_field=unit_field, xml_field=xml_field):
                unit_value = group_unit[unit_field]
                unit_text = _xml_text_for_boolean(unit_value)
                xml_text = group_element.find(xml_field).text
                self.assertEqual(unit_text, xml_text)

    def test_default_display_order(self):
        """Assert display_order is omitted from XML if omitted from unit.

        This test may be skipped if `Pulp #1787
        <https://pulp.plan.io/issues/1787>`_ is open.
        """
        empty_group_element = _get_groups_by_id(self.root_element)['empty']
        display_order_elements = empty_group_element.findall('display_order')

        if selectors.bug_is_untestable(1787, self.cfg.version):
            self.skipTest('https://pulp.plan.io/issues/1787')

        self.assertEqual(0, len(display_order_elements))

    def test_single_elements(self):
        """Assert that certain tags appear under groups exactly once."""
        tag_names = ['default', 'uservisible', 'packagelist']

        for group_element in self.root_element.findall('group'):
            for tag in tag_names:
                with self.subTest(group_element=group_element, tag=tag):
                    elements = group_element.findall(tag)
                    self.assertEqual(1, len(elements))

    def test_default_default(self):
        """Assert that the default value of `default` tag is 'false'."""
        group_element = _get_groups_by_id(self.root_element)['empty']
        self.assertEqual('false', group_element.find('default').text)

    def test_default_uservisible(self):
        """Assert that the default value of `uservisible` tag is 'false'."""
        group_element = _get_groups_by_id(self.root_element)['empty']
        self.assertEqual('false', group_element.find('uservisible').text)

    def test_translated_string_count(self):
        """Assert that the XML has correct number of translated strings.

        Some fields (name, description) are translatable. The tags for these
        fields are expected to appear once per translation, plus once for the
        untranslated string. This test verifies that this is the case.
        """
        (group_unit, group_element) = self.group_unit_and_element(
            'additional-devel'
        )
        for field in ['name', 'description']:
            with self.subTest(field=field):
                elements = group_element.findall(field)
                unit_values = group_unit['translated_{}'.format(field)]
                # Expect one element for the untranslated value, plus one per
                # translated value.
                expected_len = 1 + len(unit_values)
                self.assertEqual(expected_len, len(elements))

    def test_translated_string_values(self):
        """Assert that the XML has correct values for translated strings.

        Some fields (name, description) are translatable. The tags for these
        fields are expected to appear once per translation, plus once for the
        untranslated string. This test verifies that each translated string
        matches exactly the string provided when the group unit was imported.
        """
        (group_unit, group_element) = self.group_unit_and_element(
            'additional-devel'
        )
        lang_attr = '{http://www.w3.org/XML/1998/namespace}lang'

        for field in ['name', 'description']:
            with self.subTest(field=field):
                unit_field = 'translated_{}'.format(field)
                elements = group_element.findall(field)
                for element in elements:
                    lang = element.get(lang_attr)
                    if not lang:
                        # This is the untranslated value
                        continue

                    with self.subTest(lang=lang):
                        unit_text = group_unit[unit_field][lang]
                        xml_text = element.text
                        self.assertEqual(unit_text, xml_text)

    def test_packagelist_values(self):
        """Assert packagelist contains packagereq elements with correct text.

        This test verifies that, for each of the 4 possible types of package
        in a group, the packagelist in the group XML contains exactly the
        package names in the uploaded unit.
        """
        (group_unit, group_element) = self.group_unit_and_element(
            'additional-devel'
        )

        package_types = ['mandatory', 'default', 'optional', 'conditional']

        for package_type in package_types:
            unit_key = '{}_package_names'.format(package_type)
            xpath = 'packagelist/packagereq[@type="{}"]'.format(package_type)
            with self.subTest(package_type=package_type):
                packagereq_elements = group_element.findall(xpath)
                unit_values = group_unit[unit_key]

                if package_type == 'conditional':
                    # 'conditional' is special: it maps a package name to a
                    # required package. In this test, we only test the
                    # package name part. See test_conditional_requires for
                    # testing the 'requires' attribute.
                    unit_values = [key
                                   for (key, _) in unit_values]

                unit_values = sorted(unit_values)
                xml_values = sorted([e.text for e in packagereq_elements])
                self.assertEqual(unit_values, xml_values)

    def test_conditional_requires(self):
        """Assert ``requires`` attributes are correct on conditional packages.

        This test assumes :meth:`test_packagelist_values` has passed.
        """
        (group_unit, group_element) = self.group_unit_and_element(
            'additional-devel'
        )

        xpath = 'packagelist/packagereq[@type="conditional"]'
        conditional_packages_by_name = {
            elem.text: elem
            for elem in group_element.findall(xpath)
        }

        for (name, requires) in group_unit['conditional_package_names']:
            with self.subTest(name=name):
                element = conditional_packages_by_name[name]
                self.assertEqual(requires, element.get('requires'))

    def group_unit_and_element(self, group_id):
        """From the root element, get group unit and element for the given ID.

        :returns: tuple of (`dict`, `Element`)
        """
        group_unit = self.groups[group_id]
        group_element = _get_groups_by_id(self.root_element)[group_id]
        return group_unit, group_element
