# coding=utf-8
"""Utility functions for RPM API tests."""
from __future__ import unicode_literals

import io
import gzip
from xml.etree import ElementTree

from pulp_smash import api, utils
from pulp_smash.compat import urljoin


def gen_repo():
    """Return a semi-random dict for use in creating an RPM repository."""
    return {
        'id': utils.uuid4(),
        'importer_config': {},
        'importer_type_id': 'yum_importer',
        'notes': {'_repo-type': 'rpm-repo'},
    }


def gen_distributor():
    """Return a semi-random dict for use in creating a YUM distributor."""
    return {
        'auto_publish': False,
        'distributor_id': utils.uuid4(),
        'distributor_type_id': 'yum_distributor',
        'distributor_config': {
            'http': True,
            'https': True,
            'relative_url': utils.uuid4() + '/',
        },
    }


def sync_repo(server_config, href):
    """Sync the referenced repository. Return the raw server response.

    :param pulp_smash.config.ServerConfig server_config: Information about the
        Pulp server being targeted.
    :param href: The path to the repository to sync.
    :returns: The server's response.
    """
    return api.Client(server_config).post(
        urljoin(href, 'actions/sync/'),
        {'override_config': {}}
    )


def xml_handler(_, response):
    """API response handler for fetching XML generated by yum distributor.

    Checks status code and returns an ElementTree for the response.

    Note that the entire response XML is loaded and parsed before returning,
    so this may be unsafe for use with large XML files.

    If the response URL ends in .gz, the XML will be automatically
    decompressed.

    Currently ignores Content-Type and Content-Encoding headers from server
    due to https://pulp.plan.io/issues/1781 .
    """
    response.raise_for_status()

    # It would be better if this were based on server response headers and
    # not guessed on filename.
    # See https://pulp.plan.io/issues/1781
    is_gzip = True if response.request.url.endswith('.gz') else False

    if is_gzip and 'decompress' in dir(gzip):
        # python 3
        text = gzip.decompress(response.content)  # pylint: disable=no-member
        text = str(text, 'utf-8')
        return ElementTree.fromstring(text)
    elif is_gzip:
        # python 2
        compressed = io.BytesIO(response.content)
        decompressed = gzip.GzipFile(fileobj=compressed)
        return ElementTree.parse(decompressed)
    else:
        return ElementTree.fromstring(response.text)


class BaseRepoMDTestCase(utils.BaseAPITestCase):
    """Base class for tests processing repomd-format repositories."""

    @classmethod
    def get_repodata_xml(cls, repo_url, repomd_type):
        """Fetch and return an XML reader for the XML of the requested type.

        repomd.xml from the given repo_url is parsed to resolve the
        reference to the specified type. An exception is raised if the
        requested repodata can't be fetched.
        """
        repomd_url = urljoin(repo_url, 'repodata/repomd.xml')

        client = api.Client(cls.cfg, xml_handler)

        repomd_xml = client.get(repomd_url)

        namespace = 'http://linux.duke.edu/metadata/repo'
        xpath = "{%s}data[@type='%s']/{%s}location" % (namespace, repomd_type,
                                                       namespace)
        location = repomd_xml.findall(xpath)

        if len(location) != 1:
            raise ValueError('%d location tags' % len(location))

        href = location[0].get('href')

        return client.get(urljoin(repo_url, href))

    def get_single_element(self, elem, expr):
        """Assert elem has exactly one element matching given xpath expression.

        Returns the child element.
        """
        matched = elem.findall(expr)

        self.assertEqual(1, len(matched),
                         ('element %s was expected to have exactly one '
                          'element matching %s')
                         % (elem, expr))

        return matched[0]
