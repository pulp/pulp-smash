# coding=utf-8
"""Utility functions for RPM API tests."""
from __future__ import unicode_literals

import gzip
import io
from xml.etree import ElementTree

from pulp_smash import api, utils
from pulp_smash.compat import urljoin

NAMESPACE = 'http://linux.duke.edu/metadata/repo'
"""An XPath namespace used by ``repomd.xml`` files."""


def gen_repo():
    """Return a semi-random dict for use in creating an RPM repository."""
    return {
        'id': utils.uuid4(),
        'importer_config': {},
        'importer_type_id': 'yum_importer',
        'notes': {'_repo-type': 'rpm-repo'},
    }


def gen_distributor():
    """Return a semi-random dict for use in creating a YUM distributor."""
    return {
        'auto_publish': False,
        'distributor_id': utils.uuid4(),
        'distributor_type_id': 'yum_distributor',
        'distributor_config': {
            'http': True,
            'https': True,
            'relative_url': utils.uuid4() + '/',
        },
    }


def get_repomd_xml_href(repomd_xml, repomd_type):
    """Parse a ``repomd.xml`` string. Find and return a path.

    Given a ``repomd.xml`` file as a string, use an XPath selector (with
    namespace :data:`pulp_smash.tests.rpm.api_v2.utils.NAMESPACE`) to find a
    path. The XML should have this general form::

        <data type="…"><location href="…" /></data>

    Return the "href" attribute.

    :param repomd_xml: A ``repomd.xml`` file, as a string.
    :param repomd_type: A "type" attribute of a "data" element. For example:
        "updateinfo".
    :returns: A path.
    :raises: ``ValueError`` if more than one "location" element is found.
    """
    xpath = (
        "{{{namespace}}}data[@type='{type}']/{{{namespace}}}location"
        .format(namespace=NAMESPACE, type=repomd_type)
    )
    location_elements = ElementTree.fromstring(repomd_xml).findall(xpath)
    if len(location_elements) != 1:
        raise ValueError(
            'The XML tree repomd_xml should only contain one matching '
            '"location" element, but {} were found with the XPath selector {}'
            .format(len(location_elements), xpath)
        )
    return location_elements[0].get('href')


def get_repomd_xml(client, repo_url, repomd_type):
    """Retrieve XML of a particular type from a repo.

    Given the URL of a repository, fetches, parses and returns the repository
    XML of the type given by ``repomd_type``.

    :param client: A :class:`pulp_smash.api.Client` used for downloading
           content from the repository.
    :param repomd_url: Top-level URL of a repomd repository. This should not
           include the path to the ``repodata`` directory.
    :param repomd_type: a type of repomd data, as found in the top-level
           ``repomd.xml`` file of a repository.  For example, "updateinfo",
           "group".
    :returns: An :class:`xml.etree.ElementTree.Element` containing the parsed
              repository metadata of the requested type.
    """
    original_handler = client.response_handler
    try:
        # Fetch and parse repomd.xml
        client.response_handler = api.safe_handler
        path = urljoin(repo_url, 'repodata/repomd.xml')
        repomd_xml = client.get(path).text

        # Fetch and parse updateinfo.xml (or updateinfo.xml.gz)
        client.response_handler = xml_handler
        path = urljoin(repo_url, get_repomd_xml_href(repomd_xml, repomd_type))
        return client.get(path)
    finally:
        client.response_handler = original_handler


def sync_repo(server_config, href):
    """Sync the referenced repository. Return the raw server response.

    :param pulp_smash.config.ServerConfig server_config: Information about the
        Pulp server being targeted.
    :param href: The path to the repository to sync.
    :returns: The server's response.
    """
    return api.Client(server_config).post(
        urljoin(href, 'actions/sync/'),
        {'override_config': {}}
    )


def xml_handler(_, response):
    """API response handler for fetching XML generated by yum distributor.

    Check the status code of ``response``, decompress the response if the
    request URL ended in ``.gz``, and return an ``xml.etree.Element`` instance
    built from the response body.

    Note:

    * The entire response XML is loaded and parsed before returning, so this
      may be unsafe for use with large XML files.
    * The ``Content-Type`` and ``Content-Encoding`` response headers are
      ignored due to https://pulp.plan.io/issues/1781.
    """
    response.raise_for_status()
    if response.request.url.endswith('.gz'):  # See bug referenced in docstring
        with io.BytesIO(response.content) as compressed:
            with gzip.GzipFile(fileobj=compressed) as decompressed:
                xml_bytes = decompressed.read()
    else:
        xml_bytes = response.content
    # A well-formed XML document begins with a declaration like this:
    #
    #     <?xml version="1.0" encoding="UTF-8"?>
    #
    # We are trusting the parser to handle this correctly.
    return ElementTree.fromstring(xml_bytes)
